\chapter{SUMMARY AND CONCLUSION}%Titles must be capitalized.

\section{Summary}
In this research, an asynchronous KLEE was implemented also a remote solver was built to work with the asynchronous mode. Compare to the original KLEE, the major difference of the asynchronous KLEE is that it has an asynchronous solver. Previously, when an \texttt{ExecutionState} was terminated, it will trigger a function called \texttt{ProcessTestcase}. In this function, KLEE will extract the constraints from the \texttt{ExecutionState}, parse it to a data structure that can use the interface that provided by STP/Z3 solver. Then KLEE will wait for solver's response. After receiving the result from solver, KLEE will wrapped up the answer and write the testcase to disk. What asynchronous KLEE does in \texttt{ProcessTestcase} is, it extracts the constraints from the \texttt{ExecutionState}, converted to a \texttt{String} in KQuery format, which is a textual representation of constraints. Instead of sitting tight and waiting for solver's response, the asynchronous KLEE sends out a string of query command using HTTP \texttt{POST} method to a remote solver. After sending the query out, the asynchronous KLEE immediately start to execute next \texttt{ExecutionState} in its \texttt{ExecutionState} pool. 

The asynchronous KLEE optimize the procedure in producing testcase for a \texttt{ExecutionState}. In the original KLEE, it wastes a lot of time in generating testcases. Through the experiment in chapter 4, it has already been proved that the asynchronous KLEE can shorten the time for exploring paths significantly when comparing to the original version of KLEE.

A remote solver was also been wrapped up to serve the asynchronous KLEE. There are two parts of the remote solver, the HTTP server and an STP/Z3 solver. The HTTP solver is responsible for receiving query command \texttt{String} from asynchronous KLEE. Then, the server will create a file and write the query command it just receives to that file. Also, the absolute path of that file will be appended to a file called ``monitor file.'' It performs like a queue because the solver is watching the change of this file using Linux kernel subsystem called \texttt{inotify}. Once a new path was appended, the solver will know a query command just came in and is waiting for the result.

The solver's responsibility is solving constraints and producing testcases. When there is a path appended to the ``monitor file,'' the solver will read the contents of that file and parse the file to a data structure that can communicate with STP/Z3 solver. Here, some optimization will be performed before the query gets into the STP/Z3 solver. First of all, the query will be chopped into small pieces. Those pieces are independents, in another word, those small pieces is also a valid expression. This step was called ``independence constraints.'' Second, the solver will check if the expressions have been solved previously. To accomplish this goal, the solver will save a cache map in RAM. The key of the cache map is the expression, and value is the answer. If the answer exists, the expression will not be passed into the STP/Z3 solver. Otherwise, the \texttt{expression, answer} pair will be inserted into the cache map after STP/Z3 solves the expression. Unlike KLEE's implementation, the solver keeps alive until the user terminates it. Therefore, sharing cache cross binary is possible. In KLEE's implementation, the solver instance will be terminated when execution completed and the cache will be deleted. If we use KLEE to analyze the same application, it still needs to solve the expression instead of pulling out the answer directly from the cache. This situation does not happen in the remote solver. Not only the same binary can share cache, but also another program since the remote solver does not know which program is being analyzed. All it knows are just expressions. Once the there is a same expression in the cache, it will pull out the answer from the cache instead of solving it. The experiment in Chapter 4 has proved that the solver share caches cross binaries.

\section{Future Work}
Although the asynchronous KLEE has some advantages on shortening the exploration time on the engine side as well as save some extra work on the solver side, it still has many places to work on in the future. Using cache in the solver is a perfect idea, but how to save the cache can be optimized a little bit more. In the current implementation, the cache map is saved in RAM. The access time of the RAM is fast. However, when the solver keeps working, the size of the cache map is growing. Ultimately, the machine will probably run out of memory. Also, if the solver died accidentally, such as having power outage issue, the cache will be unrecoverable. To address these problems, the cache should be stored in another place. For example, in a file or in a database. And this kind of action will sacrifice the access time. 