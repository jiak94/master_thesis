%%%%%%%%%%%%%%%%
% INTRODUCTION %
%%%%%%%%%%%%%%%%
\chapter{INTRODUCTION}% Chapter titles are capitalized -- UNLV rule.

Symbolic Execution \cite{King:1976:SEP:360248.360252} is a technique that can explore all of the possible paths of a binary using a constraint solver. The method came out a long time ago, but until recentdays \cite{symbolic-execution}, it has gathered significant attention. People implemented several tools and found bugs and security vulnerabilities that buried very deep in the code in different software applications \cite{sybolic-execution-in-practice}.

The reason of why symbolic execution gathered significant attention in the recent few years is because of the development of the SMT solver \cite{DeMoura:2011:SMT:1995376.1995394}. But still, constraints solver remains one of the main challenges of symbolic execution \cite{multi-solver-support}. As a result, to increase the speed of a symbolic execution engine, we can either improve the solving speed of the solver or optimize how the symbolic execution uses the engine. Moreover, let the solver uses previous constraint result is another option. 

\section{Problem Statement}
All of the current symbolic execution engines can systematically cover all the feasible path for a binary during its analysis process. However, it has its disadvantages, that is symbolic execution engine are slower than another type of dynamic analysis tools. So, can we use some other techniques to help the analysis process go faster? I target my research on one of the popular symbolic execution tool, KLEE \cite{Cadar:2008:KUA:1855741.1855756}, and try to shorten the analysis time for a program.

\section{Research Method}

The symbolic execution engine KLEE is a synchronous engine. During its execution, it is always waiting for the response from the solver to continue the exploration. While asking the solver to generate testcases, that means the current path reaches the end, and the rest of the path exploration does not rely on that result. Therefore, waiting for the solver's response is wasting time. 

    \begin{hyp}
    \textit{Making a KLEE in asynchronous mode can significantly reduce the time that is required for covered all the path in a program.}
    \end{hyp}
    
In addition to providing KLEE an asynchronous mode, solver optimization is one of the research's goal. KLEE's implementation allows the solver using cache, so let the standalone solver using cache is one of the optimization methods.

    \begin{hyp}
    \textit{Allowing the standalone solver using cache can reduce the number of counterexamples that generated by the solver.}
    \end{hyp}

\section{Contribution}

In this research, I have the following contributions:
\begin{itemize}
    \item Allow KLEE to analysis the program in asynchronous mode.
    \item Adding feature of produce testcases for every branch node that has a possible path.
    \item Implementing a server to receive query command that KLEE sends out during the analysis process.
    \item Wrapping up a solver that checks the cache for the query before throwing it into the SMT solver to generate a counterexample. 
\end{itemize}
\section{Outline}
This thesis is consist of the following chapters.
\begin{itemize}
    \item Chapter 2: Background Knowledge and Related Work
    \item Chapter 3: Implementation
    \item Chapter 4: Experimental Evaluation
    \item Chapter 5: Summary and Conclusion
\end{itemize}